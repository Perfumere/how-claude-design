# 内置工具描述 (Builtin Tool Descriptions) 详细分析

> 类别：Builtin Tool Descriptions | 数量：19+4个 | 总计约 10,000+ tokens

---

## 概述

内置工具描述是 Claude Code 中每个可用工具的详细使用说明。这些描述告诉 AI 如何正确、安全、高效地使用每个工具。它们是"工具使用手册"。

### 工具分类

| 分类 | 工具 | Token 数 |
|------|------|---------|
| **核心工具** | TodoWrite | 2,167 |
| | Task | 1,214 |
| | Bash | 1,074 |
| | EnterPlanMode | 970 |
| **代码编辑** | Bash (Git/PR) | 1,615 |
| | Edit | 278 |
| | Write | 159 |
| | ReadFile | 439 |
| | NotebookEdit | 121 |
| **搜索工具** | Glob | 122 |
| | Grep | 300 |
| | MCPSearch | 477 |
| | MCPSearch (with tools) | 510 |
| **网络工具** | WebSearch | 334 |
| | WebFetch | 265 |
| **Plan 工具** | ExitPlanMode v2 | 450 |
| | ExitPlanMode | 342 |
| **其他工具** | Skill | 399 |
| | LSP | 255 |
| | Computer | 161 |
| | AskUserQuestion | 137 |
| **附加说明** | Bash (sandbox) | 454 |
| | Task (async return) | 201 |

---

## 一、核心工具

### 1. TodoWrite (任务管理)

**Token 数：2,167 (最大的单个工具描述)**

#### 原始提示词内容

```markdown
Use this tool to create and manage a structured task list for your current coding session.

## When to Use This Tool

Use this tool proactively in these scenarios:

1. **Complex multi-step tasks** - When a task requires 3 or more distinct steps or actions
2. **Non-trivial and complex tasks** - Tasks that require careful planning or multiple operations
3. **User explicitly requests todo list** - When the user directly asks you to use the todo list
4. **User provides multiple tasks** - When users provide a list of things to be done
5. **After receiving new instructions** - Immediately capture user requirements as todos
6. **When you start working on a task** - Mark it as in_progress BEFORE beginning work
7. **After completing a task** - Mark it as completed and add any new follow-up tasks discovered

## When NOT to Use This Tool

Skip using this tool when:
1. There is only a single, straightforward task
2. The task is trivial and tracking it provides no organizational benefit
3. The task can be completed in less than 3 trivial steps
4. The task is purely conversational or informational

## Task States

1. **pending**: Task not yet started
2. **in_progress**: Currently working on (limit to ONE task at a time)
3. **completed**: Task finished successfully

## Task Management

1. **Task States**: Use these states to track progress:
   - pending: Task not yet started
   - in_progress: Currently working on (limit to ONE task at a time)
   - completed: Task finished successfully

2. **Task Management**:
   - Update task status in real-time as you work
   - Mark tasks complete IMMEDIATELY after finishing (don't batch completions)
   - Only have ONE task in_progress at any time
   - Complete current tasks before starting new ones
   - Remove tasks that are no longer relevant from the list entirely

3. **Task Completion Requirements**:
   - ONLY mark a task as completed when you have FULLY accomplished it
   - If you encounter errors, blockers, or cannot finish, keep the task as in_progress
   - When blocked, create a new task describing what needs to be resolved
   - Never mark a task as completed if:
     - Tests are failing
     - Implementation is partial
     - You encountered unresolved errors
     - You couldn't find necessary files or dependencies

4. **Task Breakdown**:
   - Create specific, actionable items
   - Break complex tasks into smaller, manageable steps
   - Use clear, descriptive task names

## Examples of When to Use

### Example 1: Dark Mode Toggle
**User**: "I want to add a dark mode toggle to the application settings."

**Assistant**: (Creates todo list)
1. Create dark mode toggle component in Settings page
2. Add dark mode state management (context/store)
3. Implement CSS-in-JS styles for dark theme
4. Update existing components to support theme switching
5. Run tests and build process, addressing any failures

### Example 2: Rename Function
**User**: "Help me rename the function getCwd to getCurrentWorkingDirectory."

**Assistant**: (Uses grep to find all occurrences, creates todo list)
1. Update src/utils/path.ts (main definition)
2. Update src/auth/login.ts (usage 1)
3. Update src/main.ts (usage 2)
...

## When NOT to Use Examples

### Example 1: Simple Question
**User**: "How do I print 'Hello World' in Python?"

**Assistant**: (Directly answers, no todo list needed)

### Example 2: Single Simple Task
**User**: "Run npm install for me."

**Assistant**: (Runs command directly, no todo list needed)
```

#### 设计分析

##### 1. 何时使用决策树

**分析：**

```
任务到来
    │
    是否复杂?
    │
    ├─ 否 → 直接执行，不用 TodoWrite
    │
    └─ 是 → 是否 >3 步?
        │
        ├─ 否 → 考虑直接执行
        │
        └─ 是 → 使用 TodoWrite
```

##### 2. 任务状态机

**原文：**
```markdown
1. pending: Task not yet started
2. in_progress: Currently working on (limit to ONE at a time)
3. completed: Task finished successfully
```

**分析：**

```
pending (待办)
    │
    ├─ 初始状态
    ├─ 可以有多个
    └─ 等待开始
    │
    ↓ 开始工作

in_progress (进行中)
    │
    ├─ 只能有 1 个
    ├─ 当前正在做
    └─ 其他保持 pending
    │
    ↓ 完成工作

completed (已完成)
    │
    ├─ 必须完全完成
    ├─ 立即标记（不批量）
    └─ 可以移除或保留
```

##### 3. 完成标准

**原文：**
```markdown
ONLY mark a task as completed when you have FULLY accomplished it
Never mark a task as completed if:
- Tests are failing
- Implementation is partial
- You encountered unresolved errors
```

**分析：**

严格完成标准：

```
┌─────────────────────────────────────────┐
│         任务完成检查清单                 │
├─────────────────────────────────────────┤
│                                         │
│  功能实现                               │
│  ├─ 代码完成?                          │
│  ├─ 功能正确?                          │
│  └─ 满足需求?                          │
│                                         │
│  质量验证                               │
│  ├─ 测试通过?                          │
│  ├─ 无已知错误?                        │
│  └─ 代码审查通过?                      │
│                                         │
│  部署就绪                               │
│  ├─ 可以提交?                          │
│  ├─ 可以部署?                          │
│  └─ 文档完整?                          │
│                                         │
│  全部 Yes → 标记为 completed            │
│  任何 No → 保持 in_progress             │
│                                         │
└─────────────────────────────────────────┘
```

---

### 2. Task (任务代理)

**Token 数：1,214**

#### 原始提示词内容

```markdown
Launch a new agent that has access to the following tools: [Tool list].

When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use the Agent tool to perform the search for you.

## When to Use the Agent tool

**If you are searching for a keyword like "config" or "logger", or for questions like "which file does X?", the Agent tool is strongly recommended**

## When NOT to Use the Agent tool

**If you want to read a specific file path, use the Read or Glob tool instead of the Agent tool, to find the match more quickly**

**If you are searching for a specific class definition like "class Foo", use the Glob tool instead of the Agent tool, to find the match more quickly**

**If you are searching for code within a specific file or set of 2-3 files, use the Read tool instead of the Agent tool, to find the match more quickly**

**Writing code and running bash commands (use other tools for that)**

## Usage Notes

1. **Launch multiple agents concurrently whenever possible**, to maximize performance
2. **When the agent is done, it will return a single message back to you**
3. **Each agent invocation is stateless** - You will not be able to send additional messages
4. **Your prompt should contain a highly detailed task description** since you can't follow up
5. **The agent's outputs should generally be trusted**
6. **Clearly tell the agent whether you expect it to write code or just do research**

## Parameters

```json
{
  "description": "A short (3-5 word) description of the task",
  "prompt": "The task for the agent to perform"
}
```
```

#### 设计分析

##### 1. 使用场景

**分析：**

```
使用 Task 工具:
    │
    ├─ 搜索通用关键词 ("config", "logger")
    ├─ 探索性搜索 ("错误处理在哪里?")
    ├─ 不确定能找到
    └─ 需要多轮搜索

直接使用其他工具:
    │
    ├─ 读特定文件 → Read
    ├─ 搜索类定义 → Glob ("class Foo")
    ├─ 搜索特定文件内容 → Read/Grep
    └─ 写代码/运行命令 → Bash/Edit/Write
```

##### 2. 并行启动

**原文：**
```markdown
Launch multiple agents concurrently whenever possible
```

**分析：**

```
用户: "找到认证、日志、配置相关的代码"

┌─────────────────────────────────────────┐
│  Main Agent                              │
│                                          │
│  同时启动 3 个 Task Agents:              │
│                                          │
│  ┌──────────┐  ┌──────────┐  ┌────────┐ │
│  │ Agent 1  │  │ Agent 2  │  │Agent 3 │ │
│  │ 认证     │  │ 日志     │  │ 配置   │ │
│  └──────────┘  └──────────┘  └────────┘ │
│        │             │            │      │
│        └─────────────┴────────────┘      │
│                      │                   │
│                      ↓                   │
│              Main Agent 整合结果          │
└─────────────────────────────────────────┘
```

---

### 3. Bash (命令执行)

**Token 数：1,074**

#### 原始提示词内容

```markdown
Executes a given bash command in a persistent shell session with optional timeout.

## Before Executing

1. **Directory Verification**
   - If the command will create new directories or files, first use LS to verify the parent directory exists

2. **Command Execution**
   - Always quote file paths that contain spaces
   - Examples:
     - ✅ cd "/Users/name/My Documents"
     - ❌ cd /Users/name/My Documents

3. **Capture Output**
   - If output exceeds 30000 characters, output will be truncated
   - Prepare output for display

## Usage Notes

- The command argument is required
- Optional timeout in milliseconds (max 600000ms / 10 minutes)
- VERY IMPORTANT: You MUST avoid using search commands like `find` and `grep`
- Instead use Grep, Glob, or Task tools
- You MUST avoid read tools like `cat`, `head`, `tail`, and `ls`
- Use Read and LS tools instead
- When issuing multiple commands, use ';' or '&&' operator
- DO NOT use newlines (newlines are ok in quoted strings)
- All commands share the same shell session (state persists)

## Committing Changes with Git

[详细 Git 提交说明...]
```

#### 设计分析

##### 1. 安全检查

**原文：**
```markdown
1. Directory Verification - If creating files, verify parent directory exists
2. Command Execution - Always quote file paths with spaces
```

**分析：**

```
命令执行前检查:
    │
    ├─ 会创建文件/目录?
    │   ├─ 是 → 先用 LS 验证父目录存在
    │   └─ 否 → 继续
    │
    ├─ 路径包含空格?
    │   ├─ 是 → 必须加引号
    │   └─ 否 → 可选
    │
    └─ 执行命令
```

##### 2. 工具优先级

**原文：**
```markdown
MUST avoid: find, grep, cat, head, tail, ls
Should use: Grep, Glob, Task, Read, LS
```

**分析：**

```
专用工具 > Bash 命令

搜索内容:
    ❌ grep "pattern" file
    ✅ Grep tool

搜索文件:
    ❌ find . -name "*.ts"
    ✅ Glob tool

读取文件:
    ❌ cat file.txt
    ✅ Read tool

列出目录:
    ❌ ls -la
    ✅ LS tool
```

---

## 二、代码编辑工具

### 4. Edit (编辑工具)

**Token 数：278**

#### 原始提示词内容

```markdown
Performs exact string replacements in files.

## Usage

- You MUST use your Read tool at least once before editing
- When editing, preserve exact indentation (tabs/spaces) as it appears AFTER the line number prefix
- The edit will FAIL if old_string is not unique
- Use replace_all to change every instance

## Parameters

```json
{
  "file_path": "absolute path",
  "old_string": "text to replace",
  "new_string": "replacement text",
  "replace_all": false
}
```
```

#### 设计分析

##### 1. 精确匹配

**分析：**

```
Read 之前:
    1→  function hello() {
    2→    console.log("Hi");
    3→  }
    4→
    5→  function hello() {
    6→    console.log("Hello");
    7→  }

Edit 的 old_string:
    ❌ function hello() {
        console.log("Hi");
      }

    (不唯一，会失败)

    ✅ function hello() {
        console.log("Hi");
      }

    (加上更多上下文以唯一标识)
```

---

### 5. Write (写入工具)

**Token 数：159**

#### 原始提示词内容

```markdown
Writes a file to the local filesystem.

## Usage

- This will overwrite existing files
- If this is an existing file, you MUST use Read first
- ALWAYS prefer editing existing files
- NEVER write new files unless explicitly required
- NEVER proactively create documentation files
```

#### 设计分析

##### 1. 优先编辑

**分析：**

```
修改文件:
    │
    ├─ 文件存在?
    │   ├─ 是 → 优先用 Edit
    │   └─ 否 → 用 Write
    │
    └─ 原因:
        ├─ Edit 更安全（精确替换）
        ├─ Edit 保留文件结构
        └─ Write 覆盖整个文件
```

---

## 三、搜索工具

### 6. Glob (文件模式匹配)

**Token 数：122**

#### 原始提示词内容

```markdown
Fast file pattern matching tool.

## Usage

- Supports glob patterns like "**/*.js" or "src/**/*.ts"
- Returns matching file paths sorted by modification time
- Use when finding files by name patterns
- When doing open-ended searches, use Task tool instead

## Parameters

```json
{
  "pattern": "*.ts",
  "path": "/optional/path"
}
```
```

### 7. Grep (内容搜索)

**Token 数：300**

#### 原始提示词内容

```markdown
Fast content search tool using ripgrep.

## Usage

- Searches file contents using regular expressions
- Supports full regex syntax
- Filter files by pattern
- Returns matching file paths
- When doing open-ended searches, use Task tool instead

## Parameters

```json
{
  "pattern": "function.*login",
  "path": "/optional/path",
  "include": "*.ts"
}
```
```

#### 设计分析

##### 搜索工具对比

| 工具 | 搜索对象 | 使用场景 |
|------|---------|---------|
| Glob | 文件名 | 按名称模式找文件 |
| Grep | 文件内容 | 按内容模式找文件 |
| Task | 两者+探索 | 不确定时的探索性搜索 |

---

## 四、Plan 工具

### 8. EnterPlanMode (进入规划模式)

**Token 数：970**

#### 原始提示词内容

```markdown
Use this tool proactively when you're about to start working on a non-trivial implementation task.

## When to Use

**Prefer using EnterPlanMode** for implementation tasks unless they're simple.

Use it when ANY of these conditions apply:
1. New Feature Implementation: Adding meaningful new functionality
2. Multiple Valid Approaches: Task can be solved in several ways
3. Code Modifications: Changes affecting existing behavior
4. Architectural Decisions: Task requires choosing between patterns
5. Multi-File Changes: Task will likely touch >2-3 files
6. Unclear Requirements: Need to explore before understanding

## When NOT to Use

Only skip for simple tasks:
- Single-line or few-line fixes
- Adding a single function with clear requirements
- Tasks where user has given specific instructions
- Pure research/exploration tasks

## What Happens

This transitions you into plan mode where you:
- Thoroughly explore the codebase
- Design an implementation approach
- Present plan for user approval
```

#### 设计分析

##### 1. 触发条件

**分析：**

```
任务到来
    │
    是否需要 Plan Mode?
    │
    ├─ 新功能实现? → 是
    ├─ 多种方案? → 是
    ├─ 架构决策? → 是
    ├─ 多文件修改? → 是
    ├─ 需求不清? → 是
    │
    └─ 任何一个是 → 使用 EnterPlanMode
    │
    否
    │
    └─ 单行修复?
        单一函数?
        明确指令?
        纯研究?
        │
        └─ 都是 → 直接执行
```

---

### 9. ExitPlanMode (退出规划模式)

**Token 数：450 (v2), 342 (v1)**

#### 原始提示词内容

```markdown
Use this tool when you're in plan mode and have finished presenting your plan.

## Parameters

```json
{
  "plan": "Your implementation plan in markdown"
}
```

## What to Include in Your Plan

- **Summary**: What will be done
- **Files**: List of files to modify
- **Steps**: Numbered list of actions
- **Testing**: How to verify

## After Using This Tool

- WAIT for user approval
- User may ask for changes
- User may approve
- Only proceed after approval
```

#### 设计分析

##### 1. 计划呈现

**分析：**

```
Plan Mode 探索和设计完成
    │
    ↓
ExitPlanMode 呈现计划
    │
    ├─ Summary: 要做什么
    ├─ Files: 修改哪些文件
    ├─ Steps: 具体步骤
    └─ Testing: 如何验证
    │
    ↓
用户看到计划
    │
    ├─ 批准 → 执行
    ├─ 修改 → 调整计划
    └─ 拒绝 → 重新设计
```

---

## 五、网络工具

### 10. WebSearch (网页搜索)

**Token 数：334**

#### 原始提示词内容

```markdown
Allows Claude to search the web and use results to inform responses.

## Usage Notes

- Domain filtering supported
- Web search is only available in the US
- Provides up-to-date information

## Parameters

```json
{
  "query": "search query",
  "allowed_domains": ["example.com"],
  "blocked_domains": ["spam.com"]
}
```
```

### 11. WebFetch (网页获取)

**Token 数：265**

#### 原始提示词内容

```markdown
Fetches content from URL and processes with AI.

## Usage Notes

- URL must be fully-formed and valid
- Prompt should describe what information to extract
- Read-only, does not modify files
- Results may be summarized

## Parameters

```json
{
  "url": "https://example.com",
  "prompt": "Summarize the main points"
}
```
```

---

## 总结：内置工具描述设计模式

### 1. 统一结构

每个工具描述包含：
- **功能概述**: 工具做什么
- **何时使用**: 触发条件
- **何时不使用**: 反模式
- **参数说明**: 输入参数
- **使用示例**: 具体用法
- **注意事项**: 陷阱和警告

### 2. 工具优先级体系

```
专用工具 > 通用工具 > Bash 命令

Read > cat
Grep > grep
Glob > find
Task > 复杂搜索
```

### 3. 安全第一

每个工具都有：
- 使用前检查
- 安全约束
- 错误处理
- 最佳实践

---

*文档生成时间：2025年12月*
*基于 Claude Code v2.0.76*
