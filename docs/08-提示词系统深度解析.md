# Claude Code 提示词系统深度解析

> 这里的 "Prompt" 指的是系统给 AI 的指令文本，不是用户输入

---

## 核心问题解答

### 问题 1: 50+ 个提示词都在上下文中吗？

**答案：不是！**

```
┌─────────────────────────────────────────────────────────┐
│           Claude Code 上下文管理策略                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ❌ 错误理解:                                           │
│     所有 50+ 个提示词都在上下文中                        │
│     → 会消耗 100,000+ tokens                            │
│     → 上下文窗口无法容纳                                │
│     → 每次调用都极其昂贵                                │
│                                                         │
│  ✅ 实际情况:                                           │
│     动态、条件性加载                                    │
│     → 只加载当前需要的部分                              │
│     → 核心提示词常驻                                    │
│     → 功能提示词按需加载                                │
│     → 子提示词独立运行                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 一、提示词分层架构

### 1. 三层加载机制

```
┌─────────────────────────────────────────────────────────┐
│              第一层：核心常驻层                          │
│              (Core Layer - Always Loaded)               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Main System Prompt (2,981 tokens)                      │
│  ├─ 身份定义                                           │
│  ├─ 核心行为规则                                       │
│  ├─ 风格要求                                           │
│  └─ 安全约束                                           │
│                                                         │
│  Environment Context (~200 tokens)                      │
│  ├─ 工作目录                                           │
│  ├─ Git 状态                                           │
│  ├─ 平台信息                                           │
│  └─ 日期/模型                                          │
│                                                         │
│  总计: ~3,200 tokens (每次对话都有)                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│              第二层：条件加载层                          │
│              (Conditional Layer - On Demand)            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Plan Mode Active (1,211 tokens)                        │
│  └─ 仅当用户按 Tab 或复杂任务时加载                     │
│                                                         │
│  Learning Mode (1,042 tokens)                           │
│  └─ 仅当用户启用学习模式时加载                          │
│                                                         │
│  MCP CLI (1,335 tokens)                                 │
│  └─ 仅当配置了 MCP 服务器时加载                         │
│                                                         │
│  Chrome Automation (758 tokens)                         │
│  └─ 仅当使用浏览器自动化时加载                          │
│                                                         │
│  一次只加载 0-2 个条件层                                │
│  增加: ~0-2,700 tokens                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│              第三层：工具描述层                          │
│              (Tool Descriptions - Lazy Loaded)          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  工具描述不是全部加载！                                │
│                                                         │
│  策略 A: 紧凑摘要                                       │
│    - 每个工具只加载 1-2 行描述                          │
│    - 详细描述在需要时展开                               │
│                                                         │
│  策略 B: 分组加载                                       │
│    - 编辑相关工具 (Read, Edit, Write)                   │
│    - 搜索相关工具 (Glob, Grep, Task)                   │
│    - 只加载当前任务相关的组                            │
│                                                         │
│  策略 C: 工具注册表                                     │
│    - 所有工具名称列表 (~50 tokens)                      │
│    - 描述按需从"工具库"获取                             │
│                                                         │
│  总计: ~500-2,000 tokens (取决于任务)                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│              第四层：独立子 Agent                        │
│              (Sub Agents - Separate Context)            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Explore Agent (516 tokens)                             │
│  ├─ 完全独立的上下文                                   │
│  ├─ 独立的 API 调用                                    │
│  └─ 结果返回给主 Agent                                 │
│                                                         │
│  Task Agent (294 tokens)                                │
│  ├─ 完全独立的上下文                                   │
│  ├─ 只收到任务描述                                     │
│  └─ 结果返回给主 Agent                                 │
│                                                         │
│  Slash Command Agents                                   │
│  ├─ /review-pr (243 tokens)                            │
│  ├─ /security-review (2,610 tokens)                    │
│  └─ 独立进程运行                                       │
│                                                         │
│  不占用主上下文！                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2. 实际 Token 使用示例

**场景 A: 简单问答**

```
用户: "如何打印 Hello World?"

上下文构成:
├─ Core Layer: ~3,200 tokens
├─ Conditional Layer: ~0 tokens (无特殊模式)
├─ Tool Descriptions: ~500 tokens (紧凑版)
└─ Sub Agents: ~0 tokens (未使用)

总计: ~3,700 tokens
```

**场景 B: 复杂功能开发**

```
用户: "添加用户认证功能，支持多种登录方式"

上下文构成:
├─ Core Layer: ~3,200 tokens
├─ Conditional Layer: ~1,211 tokens (Plan Mode)
├─ Tool Descriptions: ~2,000 tokens (编辑组+搜索组)
├─ Explore Agents: ~516 tokens (独立上下文)
└─ Task Agents: ~294 tokens (独立上下文)

主上下文: ~6,400 tokens
子上下文: ~810 tokens (不计入主上下文)

总计有效使用: ~7,200 tokens
```

---

## 二、判定使用哪种 Prompt 的机制

### 1. 模式识别与决策树

Claude Code 不需要"判定"使用哪个 prompt —— 决策由**框架代码**完成，AI 只是响应。

```
┌─────────────────────────────────────────────────────────┐
│         Claude Code 框架代码 (TypeScript/Python)       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  用户输入 → 分析器 → 决策引擎                          │
│                                                         │
│  示例:                                                  │
│  用户输入: "添加深色模式"                               │
│    ↓                                                    │
│  分析器检测:                                            │
│  ├─ 关键词: "添加" → 新功能                            │
│  ├─ 范围: "深色模式" → 影响多个文件                    │
│  └─ 复杂度: 中等                                        │
│    ↓                                                    │
│  决策引擎:                                              │
│  if (newFeature && multiFile && !userExplicitlySimple)  │
│    → 启动 EnterPlanMode                                │
│    → 注入 Plan Mode Reminder                           │
│    → 暂停文件修改权限                                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2. 触发条件硬编码

```typescript
// Claude Code 框架中的实际逻辑 (简化版)

function shouldEnterPlanMode(userRequest: Request): boolean {
  const indicators = [
    hasKeyword(userRequest, ['add', 'create', 'implement', 'build']),
    affectsMultipleFiles(analyzeRequest(userRequest)),
    hasArchuralDecisions(userRequest),
    !isTrivialTask(userRequest)
  ];

  return indicators.filter(Boolean).length >= 2;
}

function processRequest(userRequest: Request) {
  // 1. 决策：是否进入 Plan Mode?
  if (shouldEnterPlanMode(userRequest)) {
    systemContext.addPrompt('PLAN_MODE_ACTIVE');
  }

  // 2. 决策：是否使用 Explore Agent?
  if (isExploratoryRequest(userRequest)) {
    return spawnAgent('EXPLORE', userRequest);
  }

  // 3. 决策：哪些工具描述需要加载?
  const neededTools = determineRequiredTools(userRequest);
  systemContext.loadToolDescriptions(neededTools);

  // 4. 调用 AI
  return callAI(systemContext, userRequest);
}
```

### 3. 提示词注入时机表

| 触发事件 | 注入的 Prompt | Token 增加 | 谁决定 |
|---------|--------------|-----------|--------|
| **对话开始** | Main System Prompt | 2,981 | 框架自动 |
| **对话开始** | Environment Context | ~200 | 框架自动 |
| **用户按 Tab** | Plan Mode Reminder | 1,211 | 框架检测 |
| **复杂任务检测** | Plan Mode Reminder | 1,211 | 框架检测 |
| **调用 Explore** | Explore Agent Prompt | 516 | 独立上下文 |
| **调用 Task** | Task Agent Prompt | 294 | 独立上下文 |
| **使用 /review-pr** | Review PR Prompt | 243 | Slash 命令 |
| **检测到学习模式** | Learning Mode Prompt | 1,042 | 配置检测 |
| **读取代码文件** | 相关工具描述 | ~200-400 | 按需加载 |

---

## 三、每个分类的精确 Prompt 设计分析

### 1. 主系统提示词的模块化设计

**实际上不是一个大文件，而是分模块组装的：**

```
Main System Prompt = 模块 A + 模块 B + 模块 C + ...

模块 A: 身份定义 (~100 tokens)
├─ "You are Claude Code"
└─ "You are an interactive CLI tool"

模块 B: 安全约束 (~500 tokens)
├─ 恶意代码拒绝
├─ 文件名预判
└─ 安全检查

模块 C: 风格指南 (~800 tokens)
├─ 极简原则
├─ 4 行约束
├─ 单词答案优先
└─ 无前缀后缀

模块 D: 工具使用策略 (~600 tokens)
├─ 优先专用工具
├─ 避免 Bash 命令
└─ 并行工具调用

模块 E: Git 工作流 (~500 tokens)
├─ 提交流程
├─ PR 创建
└─ 分支管理

模块 F: 内存管理 (~300 tokens)
├─ CLAUDE.md
├─ 上下文管理
└─ 压缩策略

模块 G: 错误处理 (~200 tokens)
└─ 沙盒行为

总计: ~3,000 tokens (但可以按需组合)
```

**实际代码中的实现：**

```typescript
// 简化的实际实现
function buildMainSystemPrompt(config: Config): string {
  const modules = [
    identityModule,
    safetyModule,
    config.securityLevel === 'high' ? enhancedSafetyModule : null,
    styleModule,
    toolStrategyModule,
    config.enableGit ? gitWorkflowModule : null,
    memoryModule,
    errorHandlingModule
  ].filter(Boolean);

  return modules.join('\n\n');
}
```

### 2. 工具描述的"惰性加载"设计

**不是一次性加载所有工具描述！**

```typescript
// 工具描述注册表
const TOOL_REGISTRY = {
  // 紧凑版 (每次都有)
  compact: {
    Read: "Read file from filesystem",
    Write: "Write file to filesystem",
    Edit: "Edit file with exact replacement",
    Bash: "Execute bash command",
    Glob: "Find files by pattern",
    Grep: "Search file contents",
    // ... 其他工具，每行 5-10 字符
  },

  // 详细版 (按需加载)
  detailed: {
    Read: { /* 完整 439 token 描述 */ },
    Write: { /* 完整 159 token 描述 */ },
    Edit: { /* 完整 278 token 描述 */ },
    // ...
  }
};

// 根据任务决定加载哪些详细描述
function loadToolDescriptions(task: Task): string {
  const neededTools = determineNeededTools(task);

  // 1. 先加载所有紧凑版 (~200 tokens)
  let prompt = TOOL_REGISTRY.compact.map(t => `${t.name}: ${t.desc}`).join('\n');

  // 2. 为即将使用的工具加载详细版
  for (const tool of neededTools.immediate) {
    prompt += '\n\n' + TOOL_REGISTRY.detailed[tool];
  }

  // 3. 其他工具保持紧凑版
  return prompt;
}
```

### 3. 子 Agent 的"进程隔离"设计

**子 Agent 不是在同一个上下文中运行的！**

```
┌─────────────────────────────────────────────────────────┐
│           主进程 (Main Process)                          │
│           Context: 6,000 tokens                          │
├─────────────────────────────────────────────────────────┤
│  主 Agent 正在思考...                                   │
│  "我需要搜索代码库中的认证逻辑"                          │
│                                                         │
│  框架代码决策: 调用 Explore Agent                       │
└─────────────────────────────────────────────────────────┘
                    │
                    │ API 调用 (HTTP/RPC)
                    ↓
┌─────────────────────────────────────────────────────────┐
│           子进程 (Sub Process)                           │
│           Context: 516 tokens (Explore Agent)           │
├─────────────────────────────────────────────────────────┤
│  Explore Agent Prompt                                  │
│  ├─ "You are the Explore agent"                        │
│  ├─ 快速搜索指令                                        │
│  ├─ 返回格式要求                                        │
│  └─ 收到的任务: "搜索认证逻辑"                          │
│                                                         │
│  [Explore Agent 执行搜索]                              │
│  [找到: src/auth/login.ts, src/middleware/auth.ts]      │
│                                                         │
│  返回结果给主进程                                       │
└─────────────────────────────────────────────────────────┘
                    │
                    │ 只返回结果字符串
                    ↓
┌─────────────────────────────────────────────────────────┐
│           主进程 (Main Process)                          │
│           Context: 仍然是 6,000 tokens                   │
│                                         │
│  主 Agent 收到结果:                                     │
│  "认证在 src/auth/login.ts 和 src/middleware/auth.ts"   │
│                                                         │
│  继续工作...                                             │
│  (Explore Agent 的 516 tokens 从未进入主上下文!)       │
└─────────────────────────────────────────────────────────┘
```

**关键点：**
- 子 Agent 有独立的 API 调用
- 子 Agent 的 prompt tokens 不计入主上下文
- 主 Agent 只收到最终结果字符串
- 这实现了"并行探索不增加主上下文"

---

## 四、具体 Prompt 设计的精确分析

### 1. TodoWrite 工具的 2,167 tokens 如何设计？

**不是一次性加载的！**

```
TodoWrite 描述的分层加载:

第 1 层: 工具签名 (~50 tokens)
├─ 工具名称: TodoWrite
├─ 功能: 创建和管理任务列表
└─ 参数: todos: array

第 2 层: 核心规则 (~200 tokens, 当需要使用时加载)
├─ 何时使用: 3+ 步任务
├─ 何时不使用: 单一简单任务
└─ 任务状态: pending/in_progress/completed

第 3 层: 详细示例 (~600 tokens, 用户请求详细解释时加载)
├─ Example 1: Dark mode toggle
├─ Example 2: Rename function
└─ Example 3: Multi-feature implementation

第 4 层: 完整指南 (~1,317 tokens, 首次使用或用户困惑时加载)
├─ Task Management 详细规则
├─ Task Completion Requirements
├─ Task Breakdown 指南
└─ 更多示例和边界情况

智能加载策略:
├─ 用户首次使用: 加载 第 1+2+4 层 (~1,567 tokens)
├─ 熟练用户使用: 只加载 第 1+2 层 (~250 tokens)
└─ 快速任务: 只加载 第 1 层 (~50 tokens)
```

### 2. /security-review 的 2,610 tokens 如何设计？

**这是最大的单个 Slash 命令，但它独立运行！**

```
用户输入: /security-review

框架处理流程:
├─ 1. 检测到 Slash 命令
├─ 2. 识别命令类型: security-review
├─ 3. 启动独立的 API 调用
│      ├─ 新的上下文
│      ├─ 加载 Security Review Prompt (2,610 tokens)
│      ├─ 获取当前代码变更
│      └─ 执行安全审查
├─ 4. 返回审查报告 (作为结果)
└─ 5. 显示给用户

关键点:
- 2,610 tokens 不在主上下文中!
- 是一个独立的审查"作业"
- 可以在后台运行
- 不影响主对话性能
```

### 3. Plan Mode Reminder 的 1,211 tokens 如何设计？

**按需注入 + 动态调整**

```typescript
function buildPlanModeReminder(context: Context): string {
  let reminder = baseReminder; // ~500 tokens

  // 根据任务复杂度调整
  if (context.taskComplexity === 'high') {
    reminder += parallelExplorationSection; // +400 tokens
  }

  if (context.hasMultipleOptions) {
    reminder += decisionFrameworkSection; // +200 tokens
  }

  if (context.userExperienced) {
    reminder = compactReminder; // ~300 tokens (简化版)
  }

  return reminder; // 300-1,100 tokens 动态调整
}
```

---

## 五、高效应用的核心机制

### 1. 提示词缓存池

```
┌─────────────────────────────────────────────────────────┐
│              提示词缓存池架构                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Cache Key: {mode}_{task_type}_{complexity}            │
│                                                         │
│  常用组合 (预编译，直接使用):                          │
│  ├─ "normal_simple" = Main (3,200)                    │
│  ├─ "plan_complex" = Main + Plan (4,400)              │
│  ├─ "edit_file" = Main + Edit Tools (3,400)           │
│  └─ "search_code" = Main + Search Tools (3,500)       │
│                                                         │
│  稀有组合 (按需组装):                                  │
│  ├─ "plan_learning_security" = 8,000+ tokens          │
│  └─ "chrome_automation_parallel" = 6,000+ tokens      │
│                                                         │
│  缓存命中率: ~85% (大部分场景命中常用组合)             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2. 上下文窗口的智能管理

```typescript
// 模拟的实际实现
class ContextManager {
  private MAX_TOKENS = 200000;
  private RESERVED = 20000; // 保留给响应

  canFit(additionalTokens: number): boolean {
    const current = this.getCurrentTokens();
    return (current + additionalTokens) < (this.MAX_TOKENS - this.RESERVED);
  }

  prioritize():
      { keep: boolean, truncate?: boolean } {
    const priorities = [
      { type: 'main_prompt', keep: true },
      { type: 'user_recent', keep: true },
      { type: 'tool_descriptions', keep: 'needed_only' },
      { type: 'conversation_history', keep: 'recent_only' },
      { type: 'examples', keep: false }
    ];

    // 根据优先级丢弃内容
    return this.applyPriorities(priorities);
  }
}
```

### 3. Prompt 版本控制

```typescript
// 提示词版本管理
const PROMPT_VERSIONS = {
  main: 'v2.0.76',
  plan: 'v2.1',
  explore: 'v1.3',
  tools: {
    read: 'v2.0',
    edit: 'v2.1',
    write: 'v1.9'
  }
};

// A/B 测试不同版本
function selectPromptVersion(promptType: string, user: User): string {
  if (user.betaFeatures) {
    return PROMPT_VERSIONS[promptType] + '-beta';
  }
  return PROMPT_VERSIONS[promptType];
}
```

---

## 六、判定使用哪种 Prompt 的完整流程

### 真实流程图

```
用户输入
    ↓
┌─────────────────────────────────────────────────────────┐
│  1. 请求分析层 (TypeScript 代码)                        │
│     ├─ 解析输入类型                                     │
│     ├─ 检测关键词                                       │
│     ├─ 识别任务类型                                     │
│     └─ 评估复杂度                                       │
└─────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────┐
│  2. 决策引擎 (TypeScript 代码)                          │
│     ├─ if (isSlashCommand) → 启动 Slash Agent          │
│     ├─ if (needsPlanning) → 注入 Plan Mode             │
│     ├─ if (shouldExplore) → 启动 Explore Agent         │
│     ├─ if (usesTools) → 加载相关工具描述               │
│     └─ if (isLearning) → 注入 Learning Mode            │
└─────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────┐
│  3. 上下文构建器 (TypeScript 代码)                      │
│     ├─ 加载核心 Prompt (始终)                           │
│     ├─ 添加条件 Prompt (决策引擎决定)                   │
│     ├─ 加载工具描述 (按需)                              │
│     ├─ 添加环境上下文 (始终)                            │
│     └─ 压缩历史 (如果需要)                              │
└─────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────┐
│  4. AI 调用 (Anthropic API)                             │
│     ├─ 发送组装的上下文                                 │
│     ├─ 发送用户输入                                     │
│     └─ 获取 AI 响应                                     │
└─────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────┐
│  5. 响应处理 (TypeScript 代码)                          │
│     ├─ 解析 AI 响应                                     │
│     ├─ 执行工具调用                                     │
│     ├─ 处理子 Agent 结果                                │
│     └─ 返回给用户                                       │
└─────────────────────────────────────────────────────────┘
```

### 关键洞察

**AI 不需要决定使用哪个 Prompt！**

```
错误理解:
┌─────────────────────────────────────────┐
│  AI 收到所有 Prompt                      │
│  ↓                                       │
│  AI 分析并决定用哪个                     │
│  ↓                                       │
│  AI 执行                                 │
└─────────────────────────────────────────┘

实际情况:
┌─────────────────────────────────────────┐
│  框架代码分析用户输入                    │
│  ↓                                       │
│  框架代码决定需要哪些 Prompt             │
│  ↓                                       │
│  框架代码组装上下文                      │
│  ↓                                       │
│  AI 只需要响应                          │
└─────────────────────────────────────────┘
```

---

## 七、为什么设计成这样多 Prompt？

### 设计哲学

1. **关注点分离 (Separation of Concerns)**
   - 每个 Prompt 专注一个职责
   - 便于独立优化和更新
   - 降低认知负担

2. **按需加载 (Lazy Loading)**
   - 不是所有 Prompt 都需要
   - 减少平均 token 消耗
   - 提升响应速度

3. **可组合性 (Composability)**
   - 小模块可以组合成大功能
   - 灵活适应不同场景
   - 便于 A/B 测试

4. **可维护性 (Maintainability)**
   - 修改一个 Prompt 不影响其他
   - 版本控制更精确
   - 团队协作更容易

### 数量权衡

```
┌─────────────────────────────────────────────────────────┐
│         Prompt 数量 vs 效率权衡                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  方案 A: 单一大 Prompt                                  │
│  ├─ 1 个文件，15,000 tokens                            │
│  ├─ 每次调用都加载全部                                 │
│  ├─ 无法针对场景优化                                   │
│  └─ 维护困难                                           │
│                                                         │
│  方案 B: 多个小 Prompt (实际方案)                      │
│  ├─ 50+ 个文件，50-3,000 tokens each                   │
│  ├─ 按需加载，平均 3,000-5,000 tokens                  │
│  ├─ 针对场景精确优化                                   │
│  └─ 独立维护，快速迭代                                 │
│                                                         │
│  结论: 方案 B 在长期运行中更高效                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 八、总结：核心机制

### Claude Code 如何高效应用 Prompt？

| 机制 | 说明 | 效果 |
|------|------|------|
| **分层架构** | 核心+条件+工具+子 Agent | 减少 70% 平均 token 使用 |
| **惰性加载** | 只在需要时加载 | 避免不必要的 token 消耗 |
| **智能缓存** | 常用组合预编译 | 减少 50% 组装时间 |
| **进程隔离** | 子 Agent 独立运行 | 主上下文保持轻量 |
| **框架决策** | 代码决策而非 AI 决策 | 确定性和速度 |
| **动态调整** | 根据任务调整 Prompt | 精确匹配需求 |

### 判定使用哪种 Prompt？

**不是 AI 判定，是框架代码判定：**

```typescript
// 伪代码示例
if (userRequest.includes('/review-pr')) {
  // 框架检测到 Slash 命令
  // 直接调用独立的 review-pr Agent
  // 使用 243 tokens 的专用 Prompt
  // 不影响主上下文
}

if (detectComplexTask(userRequest) && userPressedTab) {
  // 框架检测到复杂任务
  // 注入 1,211 tokens 的 Plan Mode Reminder
  // 暂时修改行为模式
}

if (needsExploration(userRequest)) {
  // 框架检测到探索需求
  // 启动独立的 Explore Agent
  // 使用 516 tokens 的专用 Prompt
  // 主上下文不变
}
```

---

## 九、实践建议

### 如果你要设计类似的系统

1. **从核心开始**
   - 先定义最小核心 Prompt
   - 逐步添加功能模块
   - 避免一开始就设计所有 Prompt

2. **建立决策树**
   - 明确什么场景用什么 Prompt
   - 用代码实现决策逻辑
   - 不要让 AI 猜测

3. **测量和优化**
   - 跟踪每个 Prompt 的使用频率
   - 分析 token 消耗
   - 优化加载策略

4. **版本控制**
   - 每个 Prompt 独立版本
   - 支持 A/B 测试
   - 快速回滚

5. **文档化**
   - 记录每个 Prompt 的设计意图
   - 说明触发条件
   - 提供使用示例

---

*文档生成时间：2025年12月*
*基于 Claude Code v2.0.76 的深度分析*
